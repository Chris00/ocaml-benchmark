<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tree (benchmark.Benchmark.Tree)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">benchmark</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Benchmark.Tree</span></h1></header><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>A (possibly empty) tree of benchmarks. Individual benchmarks
(i.e., calls to <a href="../index.html#val-throughputN">throughputN</a>, <a href="../index.html#val-latencyN">latencyN</a>, etc. wrapped with
(&gt;:)) can appear at any node of the tree. The edges are
annotated with strings, and paths (see <a href="index.html#type-path">path</a>) are used to
select subtrees.</p></div></div><div class="spec val" id="val-(@&gt;)"><a href="#val-(@&gt;)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(@&gt;) : string <span class="keyword">&#8209;&gt;</span> <a href="../index.html#type-samples">samples</a> Lazy.t <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">name @&gt; bench</code> returns a (named) node of the benchmark tree.
If evaluated, it simply returns samples (for instance using
<a href="../index.html#val-throughputN">throughputN</a>). If the name contains dots, it is interpreted
as a path. For examle <code class="code">&quot;a.b&quot; @&gt; bench</code> is equivalent to <code class="code">&quot;a&quot; @&gt;&gt;
      &quot;b&quot; @&gt; bench</code>.</p><p>Example (the lazy thunk is used to hide initialization code):</p><pre><code class="code">        Benchmark.Tree.(
          &quot;sort&quot; &gt;: lazy
            (let a = Array.init 1_000_000 (fun i -&gt; i) in
             Benchmark.throughput1 18 (Array.sort compare) a
            )
        ) ;;</code></pre></div></div><div class="spec val" id="val-(@&gt;&gt;)"><a href="#val-(@&gt;&gt;)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(@&gt;&gt;) : string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">name @&gt;&gt; tree</code> makes <code class="code">tree</code> accessible through the given
<code class="code">name</code>, i.e., prefix all paths in the tree by <code class="code">name</code>. It has no
effect if <code class="code">name = &quot;&quot;</code>. If the name contains dots, it is
interpreted as a path. For instance <code class="code">&quot;n1.n2&quot; @&gt;&gt; tree</code> is
equivalent to <code class="code">&quot;n1&quot; @&gt;&gt; &quot;n2&quot; @&gt;&gt; tree</code> and adds the path
<code class="code">[n1;n2]</code> as a prefix to the tree.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: is the name is invalid. At least names
corresponding to OCaml identifiers are valid.</li></ul></div></div><div class="spec val" id="val-concat"><a href="#val-concat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>concat : <a href="index.html#type-t">t</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Merge the given trees (recursively). Merging proceeds by taking the union
of all path heads in the list, and, for each such string <code class="code">x</code>,
merging recursively all subtrees reachable under <code class="code">x</code>.</p><p>For instance merging the trees <code class="code">a.{b, c}</code>, <code class="code">a.b.d</code> and <code class="code">{a.d, foo}</code>
will give the tree <code class="code">{a.(b, b.d, c, d}, d}</code>.</p></div></div><div class="spec val" id="val-(@&gt;&gt;&gt;)"><a href="#val-(@&gt;&gt;&gt;)" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>(@&gt;&gt;&gt;) : string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">name @&gt;&gt;&gt; l</code> is equivalent to <code class="code">name @&gt;&gt; concat l</code>. It names a list of
trees, and is useful to build lists of benchmarks related to some
common topic. If the name contains dots, it is interpreted
as a path.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Invalid_argument</span>: is the name is invalid. At least names
corresponding to OCaml identifiers are valid.</li></ul></div></div><div class="spec val" id="val-with_int"><a href="#val-with_int" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>with_int : (int <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> int list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">with_int f l</code> parametrize trees with several integer values
(e.g. a size). The tree <code class="code">f i</code> is prefixed with the label <code class="code">i</code>.</p></div></div><div class="spec val" id="val-print"><a href="#val-print" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print : Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Print the tree of benchmarks (its structure) on the given formatter.
Useful in combination with the <code class="code">path</code> argument of <a href="index.html#val-run">run</a></p></div></div><h3>Path</h3><div class="spec type" id="type-path"><a href="#type-path" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>path</code><code><span class="keyword"> = </span>string list</code><code></code></div><div class="doc"><p>A path in a tree, pointing at a subtree.</p></div></div><div class="spec val" id="val-print_path"><a href="#val-print_path" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print_path : Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-path">path</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"></div></div><div class="spec val" id="val-parse_path"><a href="#val-parse_path" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>parse_path : string <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-path">path</a></code></div><div class="doc"><p>Split a string into a path at the &quot;.&quot; separators.
Example: <code class="code">parse_path &quot;a.b.c&quot;</code> returns <code class="code">[&quot;a&quot;; &quot;b&quot;; &quot;c&quot;]</code>.</p></div></div><div class="spec val" id="val-prefix"><a href="#val-prefix" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prefix : <a href="index.html#type-path">path</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Add the path as a prefix to the tree, similar to repeated
calls to <code class="code">@&gt;&gt;</code>.</p></div></div><div class="spec val" id="val-filter"><a href="#val-filter" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>filter : <a href="index.html#type-path">path</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">filter p t</code> return the tree obtained by keeping all the paths
in <code class="code">t</code> that match the path <code class="code">p</code>.
Empty components <code class="code">&quot;&quot;</code> in the middle of the path are ignored.
Empty components <code class="code">&quot;&quot;</code> at the end of the path return only the
benchmarks at that level (i.e., one discards the benchmarks
pointed by paths of which <code class="code">p</code> is a strict prefix).
The special path component <code class="code">&quot;*&quot;</code> selects all subtrees at that
level (it acts as a wildcard).</p></div></div><h3>Running</h3><div class="spec type" id="type-arg_state"><a href="#type-arg_state" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>arg_state</code><code></code><code></code></div><div class="doc"></div></div><div class="spec val" id="val-arg"><a href="#val-arg" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>arg : unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-arg_state">arg_state</a><span class="keyword"> * </span>(Arg.key<span class="keyword"> * </span>Arg.spec<span class="keyword"> * </span>Arg.doc) list</code></div><div class="doc"><p><code class="code">arg ()</code> returns <code class="code">(arg, specs)</code> where <code class="code">arg</code> is a state coming
from parsing the command line using <code class="code">specs</code>. The options are:
</p><ul><li>&quot;--path&quot; or &quot;-p&quot; to add a sub-tree of benchmarks;</li><li>&quot;--tree&quot; to print the tree of benchmarks;</li><li>&quot;--all&quot; or &quot;-a&quot; to run all paths in the tree.
Note that the default state runs all benchmarks. You need to
use something like <code class="code">Arg.parse (specs @ more_specs) ...</code> to make
the above arguments available to the program user.</li></ul></div></div><div class="spec val" id="val-run"><a href="#val-run" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>run : ?&#8288;arg:<a href="index.html#type-arg_state">arg_state</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;paths:<a href="index.html#type-path">path</a> list <span class="keyword">&#8209;&gt;</span> ?&#8288;out:Format.formatter <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">run t</code> runs all benchmarks of <code class="code">t</code> and print the results to <code class="code">fmt</code>.</p><ul class="at-tag"><li><span class="at-tag parameter">Parameter</span> <span class="module-path">paths</span>: if provided, only the sub-trees corresponding to
these path is executed. Default: execute everything.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">out</span>: The formatter on which to print the output.
Default: <code class="code">Format.std_formatter</code>.</li><li><span class="at-tag parameter">Parameter</span> <span class="module-path">arg</span>: use the result of the command line parsing to direct
the run. Default: run all paths in <code class="code">path</code></li></ul></div></div><h3>Global Registration</h3><div class="spec val" id="val-global"><a href="#val-global" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>global : unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Global tree, built from calls to <a href="index.html#val-register">register</a>. It is useful
to centralize all benchmarks at one place to, then, run them all</p></div></div><div class="spec val" id="val-register"><a href="#val-register" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>register : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Register a benchmark to the global registry of benchmarks.</p></div></div><div class="spec val" id="val-run_global"><a href="#val-run_global" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>run_global : ?&#8288;argv:string array <span class="keyword">&#8209;&gt;</span> ?&#8288;out:Format.formatter <span class="keyword">&#8209;&gt;</span> unit <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p>Same as <a href="index.html#val-run">run</a> on the global tree of benchmarks and parsing the
command line arguments from <code class="code">argv</code> (which is <code class="code">Sys.argv</code> by
default).</p></div></div></body></html>